# Chapter.09 - 타입 변환과 단축 평가

---

## 9.1 타입 변환이란?<br>

---

- 자바스크립트의 모든 값은 타입이 존재한다.
- 개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 **타입변환**(explicit coercion) 또는 **타입 캐스팅**(type casting)이라 한다.
- 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 자동적으로 타입이 변환되는 것을 암묵적 타입변환(implicit coercion) 또는 타입 강제 변환(type coercion)이라 한다.

```
ex)명시적타입변환
var x = 10;
var str = x.toString();      // 숫자를 문자열로 타입 캐스팅한다.
console.log(typeof str,str);  // string 10
console.log(typeof x,x); // number 10  -> x의 변수의 값이 변경된 것은 아니다.

```

```
ex)암묵적타입변환
var x= 10;
var str = x + '';       // 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로 새로운 문자열을 생성한다.
console.log(typeof str,str);    // string 10
console.log(typeof x,x);    // number 10 -> x의 변수의 값이 변경된 것은 아니다.

```

## 9.2 암묵적 타입 변환<br>

---

```
// 피연산자가 모두 문자열 타입이어야 하는 문맥
'10' + 2 // 102

// 피연산자가 모두 숫자 타입이어야 하는 문맥
5 * '10' // 50

// 피연산자 또는 표현식이 불리언 타입이어야 하는 문맥

!0 // true
if (1) { }

```

### 9.2.1 문자열 타입으로 변환<br>

```
1 + '2' // "12"
```

위 예제의 + 연산자는 피연산자 중 하나 이상의 문자열이므로 문자열 연결 연산자로 동작한다.<br>

### 9.2.2 숫자 타입으로 변환

```
1-1 // 0;
1+1 // 2;
1-'1' // 0;
1+'1' // 11;
```

```
'1' > 0 // true
```

```
+'' // 0
+'0' // 0
+'1' // 1
+'string' // NaN

+true // 1
+false // 0

+null // 0

+undefined // NaN

+Symbol() // TypeError: Cannot convert a Symbol value to a number

+{} // NaN
+[] // 0
+[10,20] // NaN
+(function()) // NaN
```

### 9.2.3 불리언 타입으로 변환<br>

## 9.3 명시적 타입 변환<br>

---

- 개발자의 의도에 따라 명시적으로 타입을 변경하는 방법은 다양하다.

### 9.3.1 문자열 타입으로 변환

문자열 타입이 아닌 값을 문자열 타입으로 변환하는 방법은 다음과 같다.

- String 생성자 함수를 new 연산자 없이 호출하는 방법
- Object.prototpye.toString 메서드를 사용하는 방법
- 문자열 연결 연산자를 이용하는 방법

```
// 1. String  생성ㅈ아 함수를 new 연산자 없이 호출하는 방법
// 숫자타입 => 문자열 타입
String(1); // "1"
String(NaN); // "NaN"
String(Infinity); // "Infinity"
String(true); // "true"
String(false); // "false"

// 2. Object.prototype.toString 메서드를 사용하는 방법
// 숫자타입 => 문자열 타입
(1).toString(); // "1"
(NaN).toString();   // "NaN"
(Infinity).toString();  // "Infinity"

// 불리언타입 => 문자열 타입
(true).toString();  // "true"
(false).toString(); // "false"

// 3. 문자열 연결 연산자를 이용하는 방법
// 숫자타입 => 문자열 타입
1 + ''; // "1"
NaN + ''; // "NaN"
Infinity + ''; // "Infinity"

// 불리언타입 => 문자열 타입
true + '';  // "true"
false + ''; // "false"
```

### 9.3.2 숫자 타입으로 변환<br>

숫자 타입이 아닌 값을 숫자 타입으로 변환하는 방법<br>

- Number 생성자 함수를 new 연산자 없이 호출하는 방법
- parseInt, parseFloat 함수를 사용하는 방법(문자열만 숫자 타입으로 변환가능)
- - 단항 산술 연산자를 이용하는 방법
- - 산술 연산자를 이용하는 방법

```
// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법
// 문자열 타입 => 숫자 타입
Number('0');b // 0
Number('-1');    // -1
Number('10.53');    // 10.53

// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환가능)
// 문자열 타입 => 숫자 타입
parseInt('0');  // 0
parseInt('-1'); // -1
parseFloat('10.53');    // 10.53

// 3. + 단항 산술 연산자를 이용하는 방법
// 문자열 타입 => 숫자 타입
+'0';   //  0
+'-1';  // -1
+'10.53';   // 10.53

// 불리언 타입 => 숫자 타입
+true;  // 1
+false; // 0

// 4. * 산술 연산자를 이용하는 방법
// 문자열 타입 => 숫자 타입
'0' * 1;    // 0
'-1' * 1;   // -1
'10.53' * 1;    // 10.53

// 불리언 타입 => 숫자 타입
true * 1;   // 1
false * 1;  // 0
```

### 9.3.3 불리언 타입으로 변환

불리언 타입이 아닌 값을 불리언 타입으로 변환하는 방법

- Boolean 생성자 함수를 new연산자 없이 호출하는 방법
- ! 부정 논리 연산자를 두 번 사용하는 방법

```
// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
// 문자열 타입 => 불리언 타입
Boolean('x');       // true
Boolean('');        // false
Boolean('false');   // true

// 숫자 타입 => 불리언 타입
Boolean(0);     // false
Boolean(1);     // true
Boolean(NaN);   // false
Boolean(Infinity);  // true

// null 타입 => 불리언 타입
Boolean(null)   // false

// undefinded 타입 => 불리언 타입
Boolean(undefined); // false

Boolean({});    // true
Boolean([]);    //  true


// 2. ! 부정 논리 연산자를 두 번 사용하는 방법
// 문자열 타입 => 불리언 타입
!!'x';  // true
!!'';   // false
!!'false';  // true

// 숫자 타입 => 불리언 타입
!!0;    // false
!!1;    // true
!!NaN;  // false
!!Infinity;  // true

//null 타입 => 불리언 타입
!!null; // false

// undefined 타입 => 불리언 타입
!!undefined // false

// 객체 타입 => 불리언 타입
!!{};   // true
!![];   // true

```
